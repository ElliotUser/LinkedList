
                                Сортированные списки.
    Списки хронящие данные в упорядоченном виде называются сортированными списками.
Элементы сортируются по значению ключа.
    Преимущество сортированного списка перед сортированным массивом - быстрая вставка
(не требующая перемещения элементов) и возможность динамического расширения списка(тогда
как массив ограничивается фиксированным размером).
    Чтобы вставить элемент в отсортированный список, алгоритм сначала перебирает элементы
в поисках подходящей позиции для вставки).
    Обнаружив позицию для вставки, алгоритм вставляет элемент обычным способом: в поле
next нового элемента заносится ссылка на следующий элемент, а в поле next предыдущего эле-
мента заносится ссылка на новый элемент. Однако при этом приходится учитывать особые случаи:
вставку нового элемента в начале или в конце списка.
    При перемещении сохраняется ссылка на предыдущий элемент, чтобы в поле next предыдущего
элемента можно было записать ссылку на новый элемент. После создания нового элемента метод
готовится к поиску: для этого current, как обычно, инициализируется значением first. Перемен-
ной previous также присваивается null; эта операция важна, потому что позднее по этому значе-
нию метод будет проверять, находится ли текущая позиция в начале списка.
    Цикл прерывается в том случае, если ключ текущего элемента (current.dData) не меньше ключа
вставляемого элемента (key); это самый типичный случай, когда элемент вставляется где-то в
середине списка.
    Однако цикл while также прерывается и в том случае, если переменная current содержит null.
Это происходит в конце списка (поле next последнего элемента равно null), а также в том случае,
если список изначально пуст (first содержит null). Таким образом, при завершении цикла while
текущая позиция может находиться в начале, в середине или в конце списка; кроме того, список может
быть пустым.
    Если текущая позиция находится в начале или список пуст, переменная previous будет равна null;
соответственно в поле first заносится ссылка на новый элемент. В противном случае текущая позиция
находится в середине или в конце списка, и в поле previous.next заносится ссылка на новый элемент.
    В любом случае полю next нового элемента присваивается current. Если текущая позиция находится
в конце списка, то поле current равно null, так что полю next нового элемента будет правильно при-
своено именно это значение.

Программа sortedList.java
    В программе sortedList.java (листинг 5.6) представлен класс SortedList с методами insert(),
remove() и displayList(). Только метод insert() отличается от своего аналога из класса несортиро-
ванного списка.
    Метод main() вставляет в список два элемента с ключами 20 и 40, после чего вставляются еще
три элемента с ключами 10, 30 и 50. Элементы вставляются как в начале списка, так и в середине и в
конце — это показывает, что метод insert() правильно обрабатывает все эти особые случаи. В заверше-
ние один элемент удаляется из списка, демонстрируя тем самым, что удаление всегда выполняется от
начала списка. После каждого изменения выводится текущее содержимое списка.
Результат выполнения программы sortedList.java:
List (first-->last): 20 40
List (first-->last): 10 20 30 40 50
List (first-->last): 20 30 40 50

                                Эффективность сортированных списков
    Вставка и удаление произвольных элементов в сортированных связанных списках требуют O(N) сравнений
(в среднем N/2), потому что позицию для выполнения операции приходится искать перебором списка. С дру-
гой стороны, поиск или удаление наименьшего значения выполняется за время O(1), потому что оно всегда
находится в начале списка. Если приложение часто обращается к наименьшему элементу, а скорость вставки
не критична, то сортированный связанный список будет достаточно эффективным. Например, приоритетная
очередь может быть реализована на базе сортированного связанного списка.
